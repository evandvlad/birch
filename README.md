Birch - шаблонизатор с предварительной компиляцией шаблонов. В нем не используется вызовы new Function или eval (eval less), 
поэтому он в первую очередь предназначен для сред где данные конструкции запрещены или нежелательны. Также не предоставляется 
явный доступ к глобальному объекту.
   
#### Возможности ####
* Вывод переменных 
* Вывод свойств объектов или элементов массива
* Вывод результатов вызова методов с поддержкой передачи аргументов (без вложенности вызовов методов)
* Экранированный вывод
* Условные выражения if/else с поддержкой вложенности
* Циклы по массивам с поддержкой уровня вложенности
* Возможность замены шаблона парсера

#### Производительность ####
[http://jsperf.com/template-engines-performance-compiling-rendering/2](http://jsperf.com/template-engines-performance-compiling-rendering/2)

#### Синктаксис ####

    PRINT_TOKEN = "="
    SAFE_PRINT_TOKEN = "~"
    IF_TOKEN = "?"
    ELSE_TOKEN = "!?"
    END_IF_TOKEN = "/?"
    EACH_TOKEN = "^"
    END_EACH_TOKEN = "/^"

    IDENT = Char{Char | Digit | "_"}
    PROP = "[" IDENT "]" | "." IDENT
    ARG = IDENT{PROP}
    FCALL = "(" [ARG {"," ARG] ")"
    QNAME = IDENT{PROP | FCALL}

    PRINT = PRINT_TOKEN QNAME
    SAFE_PRINT = SAFE_PRINT_TOKEN QNAME
    IF = IF_TOKEN QNAME
    ELSE = ELSE_TOKEN
    END_IF = END_IF_TOKEN
    EACH = EACH_TOKEN QNAME "->" IDENT ["," IDENT]
    END_EACH = END_EACH_TOKEN
    
Если операции ожидается значение, то операция должна отделяться от значения не менее чем одним пробелом.

По умолчанию, в инструкциях используются ограничители '{{' и '}}' в шаблоне регулярного выражения /\{{2}(.+?)\}{2}/. 
Шаблон при необходимости можно переопределить. Но сделать это необходимо до компиляции шаблонов.

    birch.tag = /<%(.+?)%>/;

#### Работа с переменными, свойствами и методами ####

Передаваемый в скомпилируемую функцию объект данных (по умолчанию - пустой объект), является для шаблонов глобальный 
объектом именно в нем происходит поиск свойств и методов.
 
    birch.compile('<div>{{= value}}</div>')({
        value : 'test'
    }); // <div>test</div>
    
    birch.compile('<div>{{= data.value }}</div>')({
        data : {
            value : 'test'
        }
    }); // <div>test</div> 
    
При работе с массивами допускается использовать как точечную, так и скобочную нотацию для доступа к элементам.

    birch.compile('<div>{{= data[0] }}</div>')({
        data : ['test']
    }); // <div>test</div> 
    
    birch.compile('<div>{{= data.0 }}</div>')({
        data : ['test']
    }); // <div>test</div>
    
Методы могут принимать произвольное количество аргументов, В качестве аргументов могут быть свойства объектов или элементы 
массивов, на любом уровне вложенности, но не вызовы других методов, т.е вложенность вызовов методов не поддерживается. 

    birch.compile('<div>{{= f() }}</div>')({
        f : function(){
            return 'test';
        }
    }); // <div>test</div>
    
    birch.compile('<div>{{= f(data.a, data.b, data.c, data.d) }}</div>')({
        f : function(a, b, c, d){
            return a + b + c + d;
        },
        data : {
            a : 't',
            b : 'e',
            c : 's',
            d : 't'
        }
    }); // <div>test</div>
    
Если метод возвращает функцию, она может быть вызвана и возвращенное ею значение обработано.
    
    birch.compile('<div>{{= f()().value }}</div>')({
        f : function(){
            return function(){
                return {value : 'test'};
            }
        }
    }); // <div>test</div>
    
#### Вывод данных ####

Реализовано два типа вывода данных, простой, определяющийся токеном '=' 

    {{= value }}
    
    birch.compile('{{= value}}')({
        value : '&'
    }); // &
    
и экранированный, определяющийся токеном '~'

    {{~ value }}
    
    birch.compile('{{~ value}}')({
        value : '&'
    }); // &amp;
    
Если значение null или undefined, возвращается пустая строка

    birch.compile('<div>{{= value}}</div>')(); // <div></div>
    
    birch.compile('<div>{{= value}}</div>')({
        value : null
    }); // <div></div>
    
#### Условные выражения ####

Обязательными для условных выражений являются операции if ('?') и endIf ('/?'), else ('!?') является опциональным. 
Инструкции endIf и else являются пустыми, инструкция if ожидает значение или результат вызова метода. Тип значения
будет приводиться к значению boolean. 

    birch.compile('{{? f() }}ok{{/?}}')({
        f : function(){
            return true;
        }
    }); // ok
    
Тело цикла if может быть пустым, т.е. инструкции if и else могут следовать друг за другом. 
    
    birch.compile('{{? value }}{{!?}}error{{/?}}')({
        value : 0
    }); // error
    
    birch.compile('{{? value }}{{!?}}error{{/?}}')({
        value : 1
    }); // ''
    
Условные выражения могут быть вложены друг в друга.

    {{? data }}
        {{? data.value }}
            {{= data.value }}
        {{!?}}
            no value
        {{/?}}
    {{!?}}
        no data
    {{/?}}
 
#### Циклы ####

Тело цикла ограничивается инструкциями each - '^' и endEach - '/^'. Последняя является пустой.
 
    birch.compile('{{^ items -> item, i }}{{= i }}.{{= item }} {{/^}}')({
        items : ['item-1', 'item-2']
    }); // 0.item-1 1.item-2
    
В инструции each необходимо задать элемент подлежащий итерации и через разделить '->' значение текущей итерации и индекс, 
значение является обязательным, индекс - нет. 

    birch.compile('{{^ items -> item }}{{= item }} {{/^}}')({
        items : ['item-1', 'item-2']
    }); // item-1 item-2
    
Внутри блока, на каждом шаге итерации создается новый scope путем расширения текущего объекта данных.

    birch.compile('{{= item }}{{^ items -> item }}{{= item }} {{/^}}{{= item }}')({
        items : ['item-1', 'item-2']
    }); // item-1 item-2
    
Циклы могут быть вложены друг в друга.

    {{^ items -> values, i }}
        {{^ values -> value, j }}
            {{= i }}.{{= j }}. {{= value }};
        {{/^}}
    {{/^}}